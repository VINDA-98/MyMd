# 01java的基础知识复习

## 1、java基础复习点

​	1、**面对相对的特性有哪些**?

​	答：封装、继承、多态、抽象

​	**封装：将对象实现的细节隐藏起来，然后通过==公共的方法==来向外暴露该对象提供的功能。**封装不仅仅是private+getter/setter，使用封装后可以对setter进行更深层次的定制，例如你可以对执行方法做一定的要求，还可以坐类型转换等，使用封装不仅仅安全，更加可以简化操作。

​	**继承：面向对象实现软件复用的重要手段，子类继承父类后，子类是一种特殊的父类，能直接或者间接获得父类里的成员。**继承有一定的缺点：

​	（1）==继承是一种强耦合关系，父类改变，子类也得随之发生改变==

​	（2）继承破坏了封装，对于父类而言，它的实现细节对于子类来说是透明的，因为子类中获得了父类中的成员方法等

​	**多态：同一个行为据有多个不同表现形式或者形态的能力。**

​	比如我眼前有一颗糖，我不知道是甜的、酸的还是咸的的，我将糖吃下后，才能得到这个糖到底是什么味道，那么我这个吃糖的动作，相对于不同的糖就能得到不同的表现形态，那么这就是多态。

​	多态的条件：1、继承； 2、重写  3、向上转型

​	多态的好处：当把不同的子类对象当作父类类型来看==，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。==	Person p = new Man(); Person p = new Mowen();

​	**抽象：从特定角度出发，从已经存在的一些事物抽取我们所关注的特性、行为，从而形成一个新的事务的思维过程，是一种从复杂到简介的思维方式。**

​	

​	2、面向对象和面向过程的区别？

​	答：**面向过程是一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程，就是确认了先做什么，再做什么。**

![image-20200930113253213](https://gitee.com/Vinda_Boy/myphoto/raw/master/img/image-20200930113253213.png)



​	**面向过程的缺陷：**
 		向过程的设计,是**采用置顶而下的设计方式**，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。

**问题：**1）设计不够直观，与人类的习惯思维不一致；2）系统软件适应性差，可扩展性差，维护性低。



​		**面向对象**是一种基于面向过程的新的编程思想，是**一种站在对象的角度思考问题**的思想，我们把多个功能合理的放到不同对象里，**强调的是具备某些功能的对象。**

![image-20200930114020445](https://gitee.com/Vinda_Boy/myphoto/raw/master/img/image-20200930114020445.png)



- **注意：** 不要粗浅的认为面向对象一定就优于面向过程的设计

> 看到知乎上有一句有意思的话：
>
> 你的程序要完成一个任务，相当于讲一个故事。
>
> 面向过程：编年体；
>  面向对象：纪传体。
>
> 而对于复杂的程序/宏大的故事，事实都证明了，面向对象/纪传是更合理的表述方法。





## 2、JDK和JRE的区别

答：Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。

​		Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。





## 3、Java 中覆盖和重载是什么意思？

答：

​	覆盖（重写）：子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，==被覆盖的方法不能是private的==，否则知识再子类中重新定义了一个新方法。

​	重载：表示一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同

​	构成重载的条件：

​		方法中的参数类型不同、参数个数不同、参数列表顺序不同

函数的返回值不同可以构成重载吗？为什么？

答：不可以，**因为 Java 中调用函数并不需要强制赋值**。举例如下：

如下两个方法：

```java
void f(){}
int f(){ return 1; }
```



## 4、Java 和 C++ 的区别

答：

都是面向对象的语言，都支持封装、继承和多态

指针：Java不提供指针来直接访问内存，程序更加安全

继承： Java的类是单继承的，C++支持多重继承；Java通过一个类实现多个接口来实现C++中的多重继承； Java中类不可以多继承，但是！！！接口可以多继承

内存： Java有自动内存管理机制，不需要程序员手动释放无用内存



 

## 5、抽象类和接口的区别有哪些？

答：

1. 抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；
2. 抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。
3. 抽象类只能单继承，接口可以继承多个父接口；
4. Java 8 中接口中会有 default 方法，即方法可以被实现。



## 6、“static” 关键字是什么意思？

答：“static” 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。

面试官：Java中是否可以覆盖(override)一个 private 或者是 static 的方法？

答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。

Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。



## 7、HashMap和Hashtable的区别有哪些？（必问）

答：

1. HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；
2. 前者允许null作为Key；后者不允许null作为Key



## 8、HashMap的底层实现你知道吗？

答：在Java8之前，其底层实现是数组+链表实现，Java8使用了数组+链表+红黑树实现。此时你可以简单的在纸上画图分析



## 9、ConcurrentHashMap 和 Hashtable 的区别？（必问）

答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如get,put,remove 等常用操作只锁当前需要用到的桶bucket。





## 10、**ConcurrentHashMap的具体实现知道吗？**

**答：**

JDK1.7：

1.  该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；
2. Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。

JDK1.8：

​	1.取消segments字段，直接采用transient volatile HashEntry<K,V>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，并发控制使用Synchronized和CAS来操作

​	2.将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构.



## 11、ArrayList 和 Vector 的区别

答：

这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。

ArrayList 与 Vector 的区别主要包括两个方面：

1. 同步性：
    Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
2. 数据增长：
    ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 1 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 0.5 倍 + 1 个空间。

**面试官：那 ArrayList 和 LinkedList 的区别呢？**

答：

1. LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；
2. LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；
3. LinkedList 比 ArrayList 需要更多的内存；

**面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？**

答：它们的区别是：

1. Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
2. Array 大小是固定的，ArrayList 的大小是动态变化的。
3. ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。

对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。



## 12、Comparable接口和Comparator接口有什么区别？

**答：**

**1.  前者简单，但是如果需要重新定义比较类型时，需要修改源代码。**

**2.  后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。**





## 13、List、Set和Map的初始容量和加载因子：

**答：**

**1. List**

- **ArrayList的初始容量是10；加载因子为0.5； 扩容增量：原容量的 0.5倍+1；一次扩容后长度为15。**
- **Vector初始容量为10，加载因子是1。扩容增量：原容量的 1倍，如 Vector的容量为10，一次扩容后是容量为20。**

**2. Set**

​	**HashSet，初始容量为16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashSet的容量为16，一次扩容后容量为32**

**3. Map**

​	**HashMap，初始容量16，加载因子为0.75； 扩容增量：原容量的 1 倍； 如 HashMap的容量为16，一次扩容后容量为32**

